/******************************************************** *	Strategy.h : 策略接口文件                           * *	张永锋                                              * *	zhangyf07@gmail.com                                 * *	2014.5                                              * *********************************************************/#ifndef STRATEGY_H_#define	STRATEGY_H_#include "Point.h"#include "Judge.h"extern "C" Point* getPoint(const int M, const int N, const int* top, const int* _board,                           const int lastX, const int lastY, const int noX, const int noY);extern "C" void clearPoint(Point* p);void clearArray(int M, int N, int** board);int m, n, nox, noy, **myboard;const int *__board;int maxDepthT = 3;int maxDepth;bool TLE, TLL;const int TL = 2000000;const int TM = 80000;clock_t start;const int INF = 1000;const int score[4] = {0, 1, 5, 15};//  连1，连2，连3分数const int NEAR = 2;int IfJudge;void Initialize(const int M, const int N, const int* _board, const int lastX, const int lastY, const int noX, const int noY, int **board){    start = clock();    IfJudge = 0;    TLE = TLL = false;    myboard = board;    if (_board != __board)    {        __board = _board;        m = M;        n = N;        nox = noX;        noy = noY;        maxDepth = 5;    }    if (lastX == -1)        maxDepth = 5;}inline bool Forbidden(int x, int y){    return x == nox && y == noy;}inline int BoardTop(int y){    int x;    for (x = m - 1; x >= 0; --x)        if (myboard[x][y] == 0 && !Forbidden(x, y))            break;    return x;}inline void JudgeTLE(clock_t &cost){    if (!TLE && cost > TL / 2)    {        TLE = true;        maxDepth--;    }}void JudgeTM(int maxval){    if (clock() - start < TM && maxval > -INF && maxval < INF)        maxDepth++;}int SearchMaxT(int depth);int SearchMinT(int depth);int SearchMax(int depth, int alpha, int beta, int f);int SearchMin(int depth, int alpha, int beta, int f);inline bool NearValid(int x, int y){    int &&delta = BoardTop(y) - x;    return delta >= 0 && delta < NEAR;}inline bool UnBlocked(int x, int y){    if (x >= 0 && y >=0 && x < m && y < n && myboard[x][y] == 0 && !Forbidden(x, y) && NearValid(x, y))        return 1;    return 0;}inline int F(int player);//  ↖️inline int F1(int &x, int &y, int &player){    int i, j;    for (i = x, j = y; i >= 0 && j >= 0; i--, j--)        if (!(myboard[i][j] == player))            break;    if (UnBlocked(i, j))        return y - j;    else        return j - y;}//  ↗️inline int F2(int &x, int &y, int &player){    int i, j;    for (i = x, j = y; i >= 0 && j < n; i--, j++)        if (!(myboard[i][j] == player))            break;        if (UnBlocked(i, j))        return x - i;    else        return i - x;}//  ➡️inline int F3(int &x, int &y, int &player){    int j;    for (j = y; j < n; j++)        if (!(myboard[x][j] == player))            break;    if (UnBlocked(x, j))        return j - y;    else        return y - j;}//  ↘️inline int F4(int &x, int &y, int &player){    int i, j;    for (i = x, j = y; i < m && j < n; i++, j++)        if (!(myboard[i][j] == player))            break;    if (UnBlocked(i, j))        return j - y;    else        return y - j;}//  ⬇️inline int F5(int &x, int &y, int &player){    int i;    for (i = x; i < m; i++)        if (!(myboard[i][y] == player))            break;    return i - x;}//  ↙️inline int F6(int &x, int &y, int &player){    int i, j;    for (i = x, j = y; i < m && j >= 0; i++, j--)        if (!(myboard[i][j] == player))            break;        if (UnBlocked(i, j))        return i - x;    else        return x - i;}//  ⬅️inline int F7(int &x, int &y, int &player){    int j;    for (j = y; j >= 0; j--)        if (!(myboard[x][j] == player))            break;    if (UnBlocked(x, j))        return y - j;    else        return j - y;}void Print(){    for (int i = 0; i < m; i++)    {        for (int j = 0; j < n; j++)            switch (myboard[i][j]) {                case 0:                    std::cout << ". ";                    break;                case 1:                    std::cout << "A ";                    break;                case 2:                    std::cout << "B ";                    break;                default:                    break;            }        std::cout << std::endl;    }}inline int IncrementalF(int x, int y, int player){    int f = 0;    int &&f1 = F1(x, y, player);    int &&f2 = F2(x, y, player);    int &&f3 = F3(x, y, player);    int &&f4 = F4(x, y, player);    int &&f5 = F5(x, y, player);    int &&f6 = F6(x, y, player);    int &&f7 = F7(x, y, player);    //Print();    //std::cout << f3 << std::endl;    f += ((f3 > 0) + (f7 > 0)) * score[-1 + abs(f3) + abs(f7)] - ((f3 > 0) + 1) * score[abs(f3) - 1] - ((f7 > 0) + 1) * score[abs(f7) - 1];    f += ((f1 > 0) + (f4 > 0)) * score[-1 + abs(f1) + abs(f4)] - ((f1 > 0) + 1) * score[abs(f1) - 1] - ((f4 > 0) + 1) * score[abs(f4) - 1];    f += ((f2 > 0) + (f6 > 0)) * score[-1 + abs(f2) + abs(f6)] - ((f2 > 0) + 1) * score[abs(f2) - 1] - ((f6 > 0) + 1) * score[abs(f6) - 1];    f += UnBlocked(x - 1, y) * score[f5] - score[f5 - 1];    return f;}#endif